import re
import os

def substitute_registers(asm_code):
    #Patterns for common instructions involving registers
    instruction_pattern = re.compile(r"(LEA|MOV|MOVZX|PUSH|CMP|SHR)\s+(EAX|ECX|EDX|EBX|ESP|EBP|ESI|EDI)(?:,\s*(EAX|ECX|EDX|EBX|ESP|EBP|ESI|EDI|DWORD PTR [\w:]+))?")

    # Register substitution map
    register_map = {
        "EAX": "EBX",
        "ECX": "EDX",
        "EDX": "ECX",
        "EBX": "EAX",
        "ESP": "EBP",
        "EBP": "ESP",
        "ESI": "EDI",
        "EDI": "ESI"
    }

    lines = asm_code.split('\n')
    result_lines = []

    for line in lines:
        instruction_match = instruction_pattern.match(line)

        if instruction_match:
            instruction, reg1, reg2 = instruction_match.groups()
            if reg1 in register_map:
                line = line.replace(reg1, register_map[reg1])
            if reg2 and reg2 in register_map:
                line = line.replace(reg2, register_map[reg2])

        result_lines.append(line)

    # Joins the processed lines back into a single string
    result_asm_code = '\n'.join(result_lines)
    return result_asm_code

def process_assembly_file(file_path):

    with open(file_path, 'r') as file:
        asm_code = file.read()

    # Process the assembly code
    processed_asm_code = substitute_registers(asm_code)


    base, ext = os.path.splitext(file_path)
    new_file_path = f"{base}_with_register_substitution{ext}"

    with open(new_file_path, 'w') as file:
        file.write(processed_asm_code)

    print(f"Processed file saved as: {new_file_path}")


file_path = 'xcr'


process_assembly_file(file_path)
