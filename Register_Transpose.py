import re
import os
import zipfile
import random

def process_assembly_file(file_path):

    with open(file_path, 'r') as file:
        asm_code = file.read()


    processed_asm_code = transpose_registers(asm_code) # Transpose the code


    with open(file_path, 'w') as file:  # rewrite the original file to hold the newly processed code
        file.write(processed_asm_code)

def process_zip_file(zip_path, output_zip_path):
    with zipfile.ZipFile(zip_path, 'r') as zip_ref:

        temp_dir = 'temp_asm_files'
        os.makedirs(temp_dir, exist_ok=True)  # Create a temporary directory
                                              # to hold the processed zip files

        zip_ref.extractall(temp_dir)


    for root, dirs, files in os.walk(temp_dir):
        for file in files:
            file_path = os.path.join(root, file)
            process_assembly_file(file_path)   # Process each file in the temp dir


    with zipfile.ZipFile(output_zip_path, 'w') as zip_ref:
        for root, dirs, files in os.walk(temp_dir):
            for file in files:                            # Output all processed files
                file_path = os.path.join(root, file)      # into a new zipped folder
                arcname = os.path.relpath(file_path, temp_dir)
                zip_ref.write(file_path, arcname=arcname)


    for root, dirs, files in os.walk(temp_dir, topdown=False):
        for file in files:
            os.remove(os.path.join(root, file))
        for dir in dirs:                             # Delete the temp directory
            os.rmdir(os.path.join(root, dir))
    os.rmdir(temp_dir)
def substitute_registers(assembly_lines):

    instruction_pattern = re.compile(r"(LEA|MOV|MOVZX|PUSH|CMP|SHR)\s+(EAX|ECX|EDX|EBX|ESP|EBP|ESI|EDI)(?:,\s*(EAX|ECX|EDX|EBX|ESP|EBP|ESI|EDI|DWORD PTR [\w:]+))?")


    register_map = {
        "EAX": "EBX",
        "ECX": "EDX",
        "EDX": "ECX",
        "EBX": "EAX",  # Array of possible substitutions
        "ESP": "EBP",
        "EBP": "ESP",
        "ESI": "EDI",
        "EDI": "ESI"
    }

    lines = assembly_lines
    result_lines = []

    for line in lines:
        instruction_match = instruction_pattern.match(line)

        if instruction_match:
            instruction, reg1, reg2 = instruction_match.groups()
            if reg1 in register_map:                           # Substitute the registers
                line = line.replace(reg1, register_map[reg1])
            if reg2 and reg2 in register_map:
                line = line.replace(reg2, register_map[reg2])

        result_lines.append(line)
    return result_lines

def insert_dead_code(assembly_lines):
    dead_code_snippets = [
        "NOP",             # Array of possible deadcode lines
        "MOV EAX, EAX",
        "XCHG EAX, EAX",
        "PUSH EBP\nPOP EBP",
        "ADD EAX, 0",
        "SUB EAX, 0",
        "LEA EAX, [EAX]",
        "PUSHFD\nPOPFD",
        "PUSHAD\nPOPAD",
    ]

    modified_lines = []
    for line in assembly_lines:
        modified_lines.append(line)
        if random.random() < 0.3:      # Randomly place deadcode throughout the asm code
            dead_code = random.choice(dead_code_snippets)
            modified_lines.append(dead_code)

    return modified_lines # Return the new script

def transpose_registers(asm_code):

    instruction_pattern = re.compile(r"(LEA|MOV|MOVZX|PUSH|CMP|SHR)\s+(EAX|ECX|EDX|EBX|ESP|EBP|ESI|EDI)(?:,\s*(EAX|ECX|EDX|EBX|ESP|EBP|ESI|EDI|DWORD PTR [\w:]+))?")



    lines = asm_code.split('\n')
    lines = insert_dead_code(lines)      # Insert the dead code
    lines = substitute_registers(lines)  # Substitute the registers
    result_lines = []

    if len(lines) <= 7:
        split = int(len(lines)/2)
    else:                          # Split the original code into every four lines
        split = int(len(lines)/4)  # Split it every 2 lines if the code is less than
    i = 0                          # 7 lines long
    part = []
    while i < len(lines):
        if i + split < len(lines):
            part.append(lines[i:i + split])
            i += split                         # Create the new asm sections
        else:
            if (lines[i:]) != ['']:
                part.append(lines[i:])
            break
    for n in range(len(part)):
        num = "sec" + str(n+1) + ":"  # Add the Section Labels
        jump = None
        if n != (len(part)-1):
            jump = "JMP sec" + str(n+2) # Add the JMP label at the end
            part[n].append(jump)        # of every section except for the last
        part[n].insert(0, num)

    random.shuffle(part)
    for lines in part:
        section = '\n'.join(lines)
        result_lines.append(section)

    result_lines.insert(0, "JMP sec1")

    result_asm_code = '\n'.join(result_lines)   
    return result_asm_code

input_zip_path = 'assembly_part_1.zip'
output_zip_path = 'assembly_part_1_with_register_transpose.zip'


process_zip_file(input_zip_path, output_zip_path)
